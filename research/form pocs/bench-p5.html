<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>p5 benchmark – vectors & auto manipulation</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  html,body{margin:0;height:100%;background:#0b0b0b;color:#ddd;font-family:system-ui}
  #ui{position:fixed;inset:auto 12px 12px auto;display:grid;gap:6px;background:#111a;padding:10px 12px;border:1px solid #222;border-radius:10px}
  #ui label{font-size:12px;opacity:.85}
  #ui input{width:220px}
  .row{display:flex;gap:8px;align-items:center}
  canvas{display:block}
</style>
</head>
<body>
<div id="ui">
  <div class="row"><label>Shapes</label><input id="shapes" type="range" min="200" max="3000" step="100" value="1200"><span id="shapesOut">1200</span></div>
  <div class="row"><label>Text copies</label><input id="texts" type="range" min="10" max="300" step="10" value="80"><span id="textsOut">80</span></div>
  <div class="row"><label>Auto change (ms)</label><input id="auto" type="range" min="200" max="2000" step="50" value="600"><span id="autoOut">600</span></div>
  <div class="row"><button id="toggle">Pause/Play</button><button id="export">Export PNG</button></div>
  <div class="row"><button id="benchStart">Start Bench (30s)</button><button id="benchEnd">End Bench</button></div>
</div>

<script src="https://unpkg.com/p5@1.9.0/lib/p5.min.js"></script>
<script>
// ===== Realistic RAF-based benchmark (p5) =====
const bench = {
  tStart: 0,
  frames: 0,
  fps: [],            // per-RAF fps samples
  overruns: 0,        // frames > 16.7ms
  lastRAF: 0,
  inputMarks: [],     // UI change timestamps
  inputLatencies: [], // UI->next frame latencies
  rafId: 0
};

function markInput(){ bench.inputMarks.push(performance.now()); }

function _rafSample(now){
  if (!bench.lastRAF) bench.lastRAF = now;
  const dt = now - bench.lastRAF;
  bench.lastRAF = now;

  if (dt > 0){
    bench.fps.push(1000 / dt);
    if (dt > 16.7) bench.overruns++;
  }
  if (bench.inputMarks.length){
    bench.inputLatencies.push(now - bench.inputMarks.shift());
  }

  bench.frames++;
  bench.rafId = requestAnimationFrame(_rafSample);
}

function benchStart(){
  bench.tStart = performance.now();
  bench.frames = 0;
  bench.fps = [];
  bench.overruns = 0;
  bench.lastRAF = 0;
  bench.inputMarks = [];
  bench.inputLatencies = [];
  cancelAnimationFrame(bench.rafId);
  bench.rafId = requestAnimationFrame(_rafSample);
}

function benchEnd(){
  cancelAnimationFrame(bench.rafId);
  const dur = (performance.now() - bench.tStart) / 1000;
  const fpsSorted = bench.fps.slice().sort((a,b)=>a-b);
  const avg = bench.fps.reduce((s,x)=>s+x,0) / Math.max(1, bench.fps.length);
  const p1  = fpsSorted[Math.floor(0.01 * fpsSorted.length)] || 0;
  const overrunsPct = bench.fps.length ? (bench.overruns / bench.fps.length) * 100 : 0;
  const medLat = bench.inputLatencies.length ? bench.inputLatencies.slice().sort((a,b)=>a-b)[Math.floor(bench.inputLatencies.length/2)] : -1;
  const heapMB = performance.memory ? Math.round(performance.memory.usedJSHeapSize/1048576) : -1;

  console.table({
    stack: 'p5',
    duration_s: dur.toFixed(1),
    avgFPS: avg.toFixed(1),
    p1LowFPS: p1.toFixed(1),
    frameBudgetOverruns_pct: overrunsPct.toFixed(1),
    medianInputLatency_ms: medLat.toFixed(1),
    heapMB
  });
}

/* ===== Params ===== */
let SHAPES=1200, TEXTS=80, AUTO_MS=600;
let running=true, nextAuto=0, t=0;

/* ===== Data ===== */
let rings=[], words=[];
const STR = "TEKST"; // vectorachtige tekst via p5 font → hier rasterized; ok voor perfvergelijking.

function setup(){
  createCanvas(window.innerWidth, window.innerHeight);
  pixelDensity(1);
  textAlign(CENTER, CENTER);
  textSize(32);
  noStroke();

  // init lots of parametric vectors (polygons/rings)
  rings = new Array(SHAPES).fill(0).map((_,i)=>({
    x: random(width), y: random(height),
    r: random(6, 60), sides: floor(random(3,8)),
    rot: random(TWO_PI), k: random(0.3, 1.2)
  }));

  // many text copies with transforms
  words = new Array(TEXTS).fill(0).map(()=>({
    x: random(width), y: random(height),
    s: random(0.5, 2.2), rot: random(TWO_PI),
    w: STR
  }));

  hookUI();
  benchStart();
}

function windowResized(){ resizeCanvas(window.innerWidth, window.innerHeight); }

function draw(){
  background(15);

  const now = millis();
  t += deltaTime*0.001;

  // auto change
  if (running && now > nextAuto){
    // pick a random bulk change to stress layout
    const which = floor(random(3));
    if (which===0){
      SHAPES = constrain(SHAPES + floor(random(-200, 200)), 200, 3000);
      rings = new Array(SHAPES).fill(0).map((_,i)=>({
        x: random(width), y: random(height),
        r: random(6, 60), sides: floor(random(3,8)),
        rot: random(TWO_PI), k: random(0.3, 1.2)
      }));
    } else if (which===1){
      TEXTS = constrain(TEXTS + floor(random(-20, 20)), 10, 300);
      words = new Array(TEXTS).fill(0).map(()=>({
        x: random(width), y: random(height),
        s: random(0.5, 2.2), rot: random(TWO_PI), w: STR
      }));
    } else {
      // global rotor
      rings.forEach(o=>o.rot += random(-0.4, 0.4));
    }
    nextAuto = now + AUTO_MS;
    markInput();
  }

  // animate rings (non-text vectors)
  fill(240); // light
  rings.forEach((o,i)=>{
    const rr = o.r * (1 + 0.25*sin(t*o.k + i*0.02));
    push();
    translate(o.x, o.y);
    rotate(o.rot + 0.3*sin(t*0.7 + i*0.01));
    polygon(0,0, rr, o.sides);
    pop();
  });

  // animate “vector text” as shapes (still canvas, but many transforms)
  fill(210);
  words.forEach((w,i)=>{
    push();
    translate(w.x, w.y);
    rotate(w.rot + 0.2*sin(t*0.6 + i*0.05));
    scale(w.s * (1 + 0.15*sin(t + i*0.3)));
    text(w.w, 0, 0);
    pop();
  });
}

function polygon(x,y,r,n){
  beginShape();
  for (let i=0;i<n;i++){
    const a = i / n * TWO_PI;
    vertex(x + cos(a)*r, y + sin(a)*r);
  }
  endShape(CLOSE);
}

function hookUI(){
  const $ = id => document.getElementById(id);
  const bind = (id, setter, out) => {
    const el=$(id), oo=$(out);
    const apply=()=>{ setter(+el.value); oo.textContent=el.value; markInput(); };
    el.addEventListener('input', apply); apply();
  };
  bind('shapes', v=>{SHAPES=v; rings = new Array(SHAPES).fill(0).map(()=>({
    x: random(width), y: random(height), r: random(6,60), sides: floor(random(3,8)), rot: random(TWO_PI), k: random(0.3,1.2)}));}, 'shapesOut');
  bind('texts', v=>{TEXTS=v; words = new Array(TEXTS).fill(0).map(()=>({
    x: random(width), y: random(height), s: random(0.5,2.2), rot: random(TWO_PI), w: STR}));}, 'textsOut');
  bind('auto', v=>{AUTO_MS=v;}, 'autoOut');

  document.getElementById('toggle').onclick = ()=> running = !running;
  document.getElementById('export').onclick = ()=> saveCanvas('p5_export','png');
  document.getElementById('benchStart').onclick = benchStart;
  document.getElementById('benchEnd').onclick = benchEnd;
}
</script>
</body>
</html>