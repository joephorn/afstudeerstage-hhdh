<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Paper.js + GSAP demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    html,body{margin:0;height:100%;background:#fafafa;font-family:system-ui,Segoe UI,Inter,Roboto,Helvetica,Arial}
    .wrap{display:grid;grid-template-columns:1fr 320px;height:100%}
    #stage{position:relative;background:#fff}
    #paper-canvas{width:100%;height:100%}
    aside{border-left:1px solid #eee;padding:16px 14px 24px 16px;overflow:auto;background:#fcfcfc}
    h1{font-size:16px;margin:0 0 12px}
    .row{display:flex;align-items:center;gap:10px;margin:8px 0}
    .row label{width:120px;font-size:12px;color:#555}
    .row input[type="range"]{flex:1}
    .row output{width:48px;text-align:right;font-variant-numeric:tabular-nums}
    .tog{display:flex;align-items:center;gap:8px;margin:8px 0;font-size:12px;color:#444}
    .footer{margin-top:16px;font-size:11px;color:#777}
    button{padding:8px 10px;border-radius:10px;border:1px solid #ddd;background:#fff;cursor:pointer}
    button:active{transform:translateY(1px)}
  </style>
</head>
<body>
<div class="wrap">
  <main id="stage">
    <canvas id="paper-canvas" resize></canvas>
  </main>
  <aside>
    <h1>Controls</h1>

    <div class="row">
      <label>Rows</label>
      <input id="rows" type="range" min="4" max="48" step="4" value="12">
      <output id="rowsOut">12</output>
    </div>

    <div class="row">
      <label>Line height (px)</label>
      <input id="line" type="range" min="1" max="25" step="1" value="8">
      <output id="lineOut">8</output>
    </div>

    <div class="row">
      <label>Height scale (%)</label>
      <input id="hscale" type="range" min="50" max="200" step="1" value="100">
      <output id="hscaleOut">100</output>
    </div>

    <div class="row">
      <label>Width (%)</label>
      <input id="wscale" type="range" min="50" max="300" step="1" value="96">
      <output id="wscaleOut">96</output>
    </div>

    <div class="row">
      <label>Gap (px)</label>
      <input id="gap" type="range" min="0" max="150" step="1" value="5">
      <output id="gapOut">5</output>
    </div>

    <div class="row">
      <label>Len threshold (px)</label>
      <input id="lenThresh" type="range" min="0" max="200" step="1" value="65">
      <output id="lenThreshOut">65</output>
    </div>

    <div class="row">
      <label>Groups (rows)</label>
      <input id="groups" type="range" min="1" max="12" step="1" value="2">
      <output id="groupsOut">2</output>
    </div>

    <div class="row">
      <label>Group size (rows)</label>
      <input id="gsize" type="range" min="1" max="12" step="1" value="3">
      <output id="gsizeOut">3</output>
    </div>

    <label class="tog">
      <input id="rounded" type="checkbox" checked>
      Rounded edges
    </label>
    <label class="tog">
      <input id="autorand" type="checkbox">
      Auto randomize (0.5s)
    </label>
    <div class="row">
      <button id="randOne">Randomize one</button>
      <button id="exportSVG">Export SVG</button>
    </div>

    <div class="footer">
      Looks for letter SVGs in <code>./src/letters/A.svg ...</code>
    </div>
  </aside>
</div>

<!-- libs -->
<script src="https://unpkg.com/paper/dist/paper-full.min.js"></script>
<script src="https://unpkg.com/gsap@3/dist/gsap.min.js"></script>

<script>
/* ========= CONFIG (gemirrord op jouw p5) ========= */
const LOGO_TEXT = "ALBION";
const PADDING   = 40;
const DISPLACE_UNIT = 20;
const TIP_RATIO = 0.25;
const TRACK_STRENGTH = 1;
const LEN_SCALE_STRENGTH = 1;
const SMALL_LEN_BIAS = 1;

const LETTERS_PATH = './src/letters/'; // A.svg enz.

/* ========= STATE ========= */
let rowsSetting = 12;
let lineThickness = 8;
let heightScale = 1.0;
let widthSetting = 0.96;
let gapSetting = 5;
let lenThreshold = 65;
let roundedEdges = true;
let displaceGroupCount = 2;
let displaceGroupSize  = 3;

let paperScope, view, layerMain;
const letterItems = [];  // Paper CompoundPaths per letter
const letterBounds = []; // bounds per letter (na schaal/plaatsing)
let rowYs = [];
let autoRandomActive = false;
let lastTick = 0;
const lerp = (a, b, t) => a + (b - a) * t;

/* ========= INIT PAPER ========= */
paper.setup(document.getElementById('paper-canvas'));
paperScope = paper;
view = paper.view;
layerMain = new paper.Layer();

/* ========= LOAD LETTER SVGs ========= */
async function loadLetter(ch){
  return new Promise((resolve,reject)=>{
    paper.project.importSVG(LETTERS_PATH + ch + '.svg', {
      expandShapes: true,
      onLoad: (item) => {
        item.visible = false;
        const cp = normalizeToPathItem(item);   // <— hier
        cp.fillColor = 'black';
        cp.strokeColor = null;
        resolve(cp);
        },
      onError: reject
    });
  });
}

async function ensureLetters(){
  if(letterItems.length) return;
  const uniq = [...new Set(LOGO_TEXT.toUpperCase().split(''))];
  const map = {};
  for(const ch of uniq){
    map[ch] = await loadLetter(ch);
  }
  for(const ch of LOGO_TEXT.toUpperCase()){
    // clone voor volgorde
    const inst = normalizeToPathItem(map[ch].clone());
    inst.visible = false;
    layerMain.addChild(inst);
    letterItems.push(inst);
  }
}

/* ========= LAYOUT: schaal & plaats letters ========= */
function layoutLetters(){
  // reset transform
  letterItems.forEach(it=>{ it.matrix = new paper.Matrix(); });

  // natuurlijke maten (na reset)
  const naturalH = Math.max(...letterItems.map(it => it.bounds.height));
  const sumW = letterItems.reduce((s,it)=> s + it.bounds.width, 0);

  const W = view.bounds.width;
  const H = view.bounds.height;

  // We willen uniform base-scale s die rekening houdt met widthSetting (horizontale stretch)
  // Gap is in pixels (niet mee-schalen)
  const totalGapsPx = (letterItems.length - 1) * gapSetting;

  const sH = (H - 2 * PADDING) / naturalH;
  const sW = (W - 2 * PADDING - totalGapsPx) / (sumW * Math.max(0.001, widthSetting));
  const s  = Math.max(0.0001, Math.min(sH, sW));

  // Voor verticale centrering moeten we ook rekening houden met heightScale
  const totalHeight = naturalH * s * Math.max(0.001, heightScale);
  const baseY = (H - totalHeight) * 0.5;

  // Totale breedte voor centrering
  const totalWidth = sumW * s * Math.max(0.001, widthSetting) + totalGapsPx;
  let penX = (W - totalWidth) * 0.5;

  letterBounds.length = 0;

  // Schaal & plaats elke letter: eerst non-uniform schalen rond top-left, dan verschuiven naar penX/baseY
  letterItems.forEach((it,i)=>{
    const b0 = it.bounds.clone();                 // natural bounds (na reset)
    // non-uniform scale: base s, plus width & height schalen
    it.scale(s * Math.max(0.001, widthSetting), s * Math.max(0.001, heightScale), b0.topLeft);
    // verplaats zodat top-left uitlijnt op penX/baseY
    const dx = penX - b0.left;
    const dy = baseY - b0.top;
    it.translate(new paper.Point(dx, dy));

    // sla actuele bounds op
    letterBounds.push(it.bounds.clone());

    // advance pen met actuele breedte + vaste gap in px
    penX += it.bounds.width + gapSetting;

    // letters zelf blijven verborgen
    it.visible = false;
  });

    // horizontaal midden (pivot) van het hele woord — nodig om cuts links/rechts te splitsen
  const minLeft  = Math.min(...letterBounds.map(b => b.left));
  const maxRight = Math.max(...letterBounds.map(b => b.right));
  containerCenterX = (minLeft + maxRight) * 0.5;


  // Bouw rijen Y-posities
  const rows = Math.max(1, rowsSetting);
  rowYs = [];
  if (rows <= 1){
    rowYs.push(H/2);
  } else {
    const top = baseY;
    const bot = baseY + totalHeight;
    for (let r = 0; r < rows; r++) {
      const t = (rows === 1) ? 0 : r / (rows - 1);
      rowYs.push(lerp(top, bot, t));
    }
  }
}

function normalizeToPathItem(item) {
  // Als het al een Path of CompoundPath is → klaar
  if (item instanceof paper.Path || item instanceof paper.CompoundPath) return item;

  // Als het een Group / Layer is: verzamel alle Paths en maak er één CompoundPath van
  const paths = item.getItems({ class: paper.Path });
  if (paths && paths.length) {
    const children = paths.map(p => p.clone({ insert: false }));
    const compound = new paper.CompoundPath({ children, insert: true });
    item.remove(); // oude group opruimen
    return compound;
  }

  // Als er alleen CompoundPaths in zitten, fuseer die als children
  const cps = item.getItems({ class: paper.CompoundPath });
  if (cps && cps.length) {
    const children = cps.map(p => p.clone({ insert: false }));
    const compound = new paper.CompoundPath({ children, insert: true });
    item.remove();
    return compound;
  }

  // fallback: laat het item staan (maar dan heb je nog steeds geen intersections)
  return item;
}

/* ========= DASH MATH ========= */
function dashLenForSpan(baseLen, maxRunLen){
  const eligible     = baseLen >= lenThreshold;
  const lenBiasBase  = (maxRunLen > 0) ? (baseLen / maxRunLen) : 0; // 0..1
  const lenBiasShort = SMALL_LEN_BIAS;
  const lenBias      = eligible ? lenBiasBase : lenBiasShort;
  return baseLen * (1 + (widthSetting - 1) * lenBias * LEN_SCALE_STRENGTH);
}

/* ========= TEKENEN ========= */
let drawLayer = new paper.Layer();

function drawScene(){
  drawLayer.removeChildren();

  // displacement per rij in groepen (zoals p5)
  const gsize = Math.max(1, displaceGroupSize);
  const groups = Math.max(1, displaceGroupCount);

  // per rij → bepaal per letter alle span-lengtes o.b.v. intersections
  for(let r=0;r<rowsSetting;r++){
    const y = rowYs[r];

    // displacement
    let xShift = 0;
    const sectionIndex = Math.floor(r / gsize) % groups; // cycle groups
    const centered = sectionIndex - (groups - 1) * 0.5;  // center around 0
    xShift = centered * DISPLACE_UNIT;

    // per letter
    letterItems.forEach((letter, li)=>{
      // horizontale lijn over de letter-bounds
      const lb = letterBounds[li];
      const x1 = lb.left - 2; // klein beetje marge
      const x2 = lb.right + 2;
      const hLine = new paper.Path.Line(
        new paper.Point(x1, y),
        new paper.Point(x2, y)
      );

      // intersecties
      const ints = letter.getIntersections(hLine)
        .map(i => i.point.x)
        .sort((a,b)=>a-b);

      // spans = paartjes [xStart, xEnd]
      const spans = [];
      for(let i=0;i+1<ints.length;i+=2){
        spans.push([ints[i], ints[i+1]]);
      }
      hLine.remove(); // niet tekenen

      // maxRunLen in deze rij (voor bias)
      let maxRunLen = 0;
      spans.forEach(([sx,ex])=>{
        const L = Math.max(0, ex - sx);
        if (L > maxRunLen) maxRunLen = L;
      });

      // render elke span → dash met taper
      spans.forEach(([sx, ex])=>{
        const rightEdgeX = ex + xShift;     // p5: right edge
        const baseLen = Math.max(0, ex - sx);
        const dashLen = Math.min(dashLenForSpan(baseLen, maxRunLen), ex - lb.left); // clamp tot envelop
        const midY    = y;
        drawCrescendoTaper(rightEdgeX, midY, dashLen, lineThickness, TIP_RATIO, roundedEdges, drawLayer);
      });
    });
  }

  paper.view.update();
}

// Crescendo-vorm streep: geleidelijk van dun → dik met ronde cap aan dikke kant en optioneel een kleine ronde tip
function drawCrescendoTaper(rightX, cy, len, h, tipRatio, roundedTip, parent){
  // Grote radius aan de rechterkant, kleine aan de linkerkant
  let R = Math.max(0.001, h * 0.5);
  let r = Math.max(0.001, R * tipRatio);

  // Clamp radii op basis van lengte
  const maxRByLen = Math.max(0.0001, len * 0.5);
  R = Math.min(R, maxRByLen);
  r = Math.min(r, R);

  // Posities
  const bigX   = rightX - R;
  const centerSep = Math.max(0, len - (R + r));   // lengte van de tapse romp
  const smallX = bigX - centerSep;

  // 1) Wigvormig lichaam (lineaire taper van r → R)
  const body = new paper.Path({
    segments: [
      [smallX, cy - r],
      [bigX,   cy - R],
      [bigX,   cy + R],
      [smallX, cy + r]
    ],
    closed: true,
    fillColor: 'black'
  });
  body.parent = parent;

  // 2) Ronde cap aan dikke kant
  const capBig = new paper.Path.Circle(new paper.Point(bigX, cy), R);
  capBig.fillColor = 'black';
  capBig.parent = parent;

  // 3) (Optioneel) kleine ronde tip
  if (roundedTip && r > 0.25) {
    const capSmall = new paper.Path.Circle(new paper.Point(smallX, cy), r);
    capSmall.fillColor = 'black';
    capSmall.parent = parent;
  }
}

/* ========= RESIZE & RENDER ========= */
function renderAll(){
  paper.view.matrix = new paper.Matrix(); // reset eventuele view transforms
  layerMain.visible = true;

  layoutLetters();
  drawScene();
}

/* ========= UI HOOKUP ========= */
function $(id){ return document.getElementById(id); }
function bind(id, setter, out){
  const el = $(id), oo = $(out);
  const apply = ()=>{
    setter(+el.value);
    oo.textContent = el.value;
    renderAll();
  };
  el.addEventListener('input', apply);
  return apply;
}

function setupUI(){
  bind('rows', v => rowsSetting = v, 'rowsOut')();
  bind('line', v => lineThickness = v, 'lineOut')();
  bind('hscale', v => heightScale = v/100, 'hscaleOut')();
  bind('wscale', v => (widthSetting = v/100), 'wscaleOut')();
  bind('gap', v => gapSetting = v, 'gapOut')();
  bind('lenThresh', v => lenThreshold = v, 'lenThreshOut')();
  bind('groups', v => displaceGroupCount = Math.max(1, v), 'groupsOut')();
  bind('gsize', v => displaceGroupSize  = Math.max(1, v), 'gsizeOut')();

  $('rounded').addEventListener('change', e => { roundedEdges = e.target.checked; renderAll(); });

  $('autorand').addEventListener('change', e=>{
    autoRandomActive = e.target.checked;
    if (autoRandomActive) lastTick = performance.now();
  });

  $('randOne').addEventListener('click', randomTweakOnce);

  $('exportSVG').addEventListener('click', ()=>{
    const svg = paper.project.exportSVG({asString:true, bounds:'content'});
    const blob = new Blob([svg], {type:'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'albion-paper.svg';
    a.click();
    URL.revokeObjectURL(url);
  });
}

function randomTweakOnce(){
  const picks = ['width','gap','groups','line','height'];
  const p = picks[Math.floor(Math.random()*picks.length)];

  if (p==='width'){
    gsap.to(window, {duration:0.3, widthSetting: gsap.utils.random(0.85,1.2), onUpdate: renderAll, ease:'power2.out'});
    $('wscale').value = Math.round(widthSetting*100); $('wscaleOut').textContent = $('wscale').value;
  } else if (p==='gap'){
    gapSetting = Math.round(gsap.utils.random(0,120)); renderAll();
    $('gap').value = gapSetting; $('gapOut').textContent = gapSetting;
  } else if (p==='groups'){
    displaceGroupCount = Math.max(1, Math.round(gsap.utils.random(1,12)));
    displaceGroupSize  = Math.max(1, Math.round(gsap.utils.random(1,12)));
    $('groups').value = displaceGroupCount; $('groupsOut').textContent = displaceGroupCount;
    $('gsize').value  = displaceGroupSize;  $('gsizeOut').textContent  = displaceGroupSize;
    renderAll();
  } else if (p==='line'){
    lineThickness = Math.round(gsap.utils.random(1,25)); renderAll();
    $('line').value = lineThickness; $('lineOut').textContent = lineThickness;
  } else if (p==='height'){
    const target = gsap.utils.random(0.7,1.3);
    gsap.to(window, {duration:0.3, heightScale: target, onUpdate: renderAll, ease:'power2.out'});
    $('hscale').value = Math.round(target*100); $('hscaleOut').textContent = $('hscale').value;
  }
}

/* ========= GSAP TICKER voor autorandom ========= */
gsap.ticker.add((time, delta)=>{
  if (!autoRandomActive) return;
  // elke ~0.5s
  const now = performance.now();
  if (now - lastTick > 500){
    lastTick = now;
    randomTweakOnce();
  }
});

/* ========= START ========= */
(async function(){
  await ensureLetters();
  setupUI();

  function onResize(){
    // Paper canvas is 'resize'; view houdt canvasmaat bij. Gewoon hertekenen:
    renderAll();
  }
  paper.view.on('resize', onResize);
  renderAll();
})();
</script>
</body>
</html>