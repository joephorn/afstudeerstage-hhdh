<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Letter Width Morph – PoC</title>
  <style>
    :root { --bg:#0b0c0f; --fg:#e8e8ea; --muted:#9aa0a6; --accent:#8ab4f8; }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
    .wrap{display:grid; grid-template-columns: 320px 1fr; gap:16px; height:100%;}
    aside{border-right:1px solid #1f2229; padding:16px; overflow:auto}
    main{position:relative}
    canvas{display:block}
    h1{font-size:16px; margin:0 0 12px}
    .field{margin:10px 0}
    .row{display:flex; align-items:center; gap:8px}
    label{display:block; font-weight:600; margin-bottom:6px}
    input[type="range"]{width:100%}
    input[type="text"]{width:100%; padding:8px 10px; border-radius:6px; border:1px solid #2a2f3a; background:#0f1116; color:var(--fg)}
    select{width:100%; padding:6px 8px; border-radius:6px; border:1px solid #2a2f3a; background:#0f1116; color:var(--fg)}
    small{color:var(--muted)}
    .hint{color:var(--muted); font-size:12px}
    .split{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Letter Width Morph – PoC</h1>

    <div class="field">
      <label for="txt">Tekst</label>
      <input id="txt" type="text" value="ALBION" maxlength="24" />
    </div>

    <div class="field">
      <label for="morph">Breedte morph (0 = normal, 1 = wide)</label>
      <div class="split">
        <input id="morph" type="range" min="0" max="1" step="0.001" value="0" />
        <label class="row" style="gap:6px">
          <input id="auto" type="checkbox" /> auto
        </label>
      </div>
    </div>

    <div class="field">
      <label for="capsize">Cap-height (px)</label>
      <input id="capsize" type="range" min="60" max="360" step="1" value="220" />
    </div>

    <div class="field">
      <label for="spacing">Letter spacing (px)</label>
      <input id="spacing" type="range" min="-40" max="1000" step="1" value="24" />
    </div>

    <div class="field">
      <label for="advance">Advance breedte (px, normal)</label>
      <input id="advance" type="range" min="40" max="1000" step="1" value="950" />
      <small>Wordt geschaald met wide-morph, zodat het woord breder wordt bij t → 1.</small>
    </div>

    <div class="field">
      <label class="row"><input id="showPts" type="checkbox" /> toon punten</label>
      <label class="row"><input id="showBox" type="checkbox" checked/> toon bbox & baseline</label>
    </div>
  </aside>
  <main id="stage"></main>
</div>

<script>
// ---------- config
const LETTERS = ['A','B','L','I','O','N'];
const BASE_PATH = './letters/'; // map met je JSONs naast dit HTML-bestand

// ---------- state
let ui = {};
let ready = false;
let glyphs = {}; // { 'A': {H, contours:[{pts:[]},...]}, 'Awide': {...}, ... }
let animT = 0;

// ---------- utils
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function hex(c){ return '#' + c.toString(16).padStart(6,'0'); }

async function fetchJSON(url){
  const res = await fetch(url);
  if (!res.ok) throw new Error('HTTP '+res.status+' for '+url);
  return await res.json();
}

async function loadGlyphs(){
  const jobs = [];
  for (const L of LETTERS){
    jobs.push(fetchJSON(BASE_PATH+L+'.json').then(j=>{ glyphs[L] = j; }));
    jobs.push(fetchJSON(BASE_PATH+L+'wide.json').then(j=>{ glyphs[L+'wide'] = j; }));
  }
  await Promise.all(jobs);
}

function mixContours(gA, gB, t){
  // Robust morph: resample closed contours to same count (arc-length), then align & lerp
  if (!gA || !gB || !gA.contours || !gB.contours) return gA || gB;

  const H = gA.H || gB.H || 1000;
  const nContours = Math.min(gA.contours.length, gB.contours.length);
  const contours = [];

  const dist = (a,b)=>{ const dx=a[0]-b[0], dy=a[1]-b[1]; return Math.hypot(dx,dy); };
  const dist2 = (a,b)=>{ const dx=a[0]-b[0], dy=a[1]-b[1]; return dx*dx+dy*dy; };

  const buildCum = (pts)=>{
    const n = pts.length; const cum = new Array(n+1); cum[0] = 0;
    for (let i=0;i<n;i++){
      const p = pts[i], q = pts[(i+1)%n];
      cum[i+1] = cum[i] + dist(p,q);
    }
    return cum; // length n+1, cum[n] == perimeter
  };
  const sampleAt = (pts, cum, s)=>{
    const n = pts.length, per = cum[n];
    // wrap s into [0, per)
    let x = s % per; if (x < 0) x += per;
    // linear scan with moving index (small n so fine)
    let i = 0;
    while (i < n && cum[i+1] < x) i++;
    const segLen = cum[i+1] - cum[i];
    const t = segLen > 1e-9 ? (x - cum[i]) / segLen : 0;
    const P = pts[i], Q = pts[(i+1)%n];
    return [ P[0] + (Q[0]-P[0])*t, P[1] + (Q[1]-P[1])*t ];
  };
  const resampleClosed = (pts, m)=>{
    const n = pts.length; if (m <= 1) return pts.slice(0, m);
    const cum = buildCum(pts); const per = cum[n];
    const out = new Array(m);
    for (let k=0;k<m;k++){
      const s = (per * k) / m; // uniform along perimeter
      out[k] = sampleAt(pts, cum, s);
    }
    return out;
  };
  const rotate = (arr, k)=> (k===0? arr.slice(): arr.slice(k).concat(arr.slice(0,k)));

  for (let ci = 0; ci < nContours; ci++){
    let A = gA.contours[ci]?.pts || [];
    let B = gB.contours[ci]?.pts || [];
    if (!A.length || !B.length) continue;

    // Resample both to same count (use the larger to preserve detail)
    const m = Math.max(A.length, B.length);
    if (A.length !== m) A = resampleClosed(A, m);
    if (B.length !== m) B = resampleClosed(B, m);
    const n = m;

    // Find best circular alignment and optional reverse
    let bestShift = 0, bestRev = false, bestErr = Infinity;
    const Brev = B.slice().reverse();
    for (let k=0; k<n; k++){
      // normal
      let e = 0; const Bk = rotate(B, k);
      for (let i=0;i<n;i++) e += dist2(A[i], Bk[i]);
      if (e < bestErr){ bestErr = e; bestShift = k; bestRev = false; }
      // reversed
      e = 0; const BRk = rotate(Brev, k);
      for (let i=0;i<n;i++) e += dist2(A[i], BRk[i]);
      if (e < bestErr){ bestErr = e; bestShift = k; bestRev = true; }
    }

    const Buse = bestRev ? rotate(Brev, bestShift) : rotate(B, bestShift);

    // Lerp
    const pts = new Array(n);
    for (let i=0;i<n;i++){
      const a = A[i], b = Buse[i];
      pts[i] = [ lerp(a[0], b[0], t), lerp(a[1], b[1], t) ];
    }
    contours.push({ closed:true, pts });
  }

  return { H, contours };
}

function drawGlyph(g, penX, baselineY, capPx, showPts){
    const s = capPx / g.H;
  if (!g || !g.contours || g.contours.length === 0) return;

  // --- determine outer (largest |area|) and ensure proper windings
  const area = (pts)=>{
    let a = 0;
    for (let i=0,n=pts.length;i<n;i++){
      const [x1,y1] = pts[i];
      const [x2,y2] = pts[(i+1)%n];
      a += x1*y2 - x2*y1;
    }
    return 0.5*a; // >0 means CCW (y-up here)
  };

  let idxOuter = 0, maxAbs = -1;
  const areas = g.contours.map(c => area(c.pts));
  for (let i=0;i<areas.length;i++){
    const aa = Math.abs(areas[i]);
    if (aa > maxAbs){ maxAbs = aa; idxOuter = i; }
  }
  const outerSign = Math.sign(areas[idxOuter]) || 1;

  // build local ordered contours: [outer, ...holes]
  const outerPts = g.contours[idxOuter].pts.slice();
  const holes = [];
  for (let i=0;i<g.contours.length;i++){
    if (i === idxOuter) continue;
    const pts = g.contours[i].pts.slice();
    // make hole wind opposite to outer
    if (Math.sign(areas[i]) === outerSign) pts.reverse();
    holes.push(pts);
  }

  noStroke();
  fill('#e8e8ea');

  // --- draw compound path
  beginShape();
  // outer (as-is; if you want outer CCW explicitly, ensure outerSign>0 else reverse)
  const outerOK = outerSign > 0 ? outerPts : outerPts.slice().reverse();
  for (const [x,y] of outerOK){
    vertex(penX + x*s, baselineY - y*s);
  }
  // holes
  for (const pts of holes){
    beginContour();
    for (const [x,y] of pts){
      vertex(penX + x*s, baselineY - y*s);
    }
    endContour();
  }
  endShape(CLOSE);

  if (showPts){
    stroke('#8ab4f8');
    strokeWeight(Math.max(1, 3/s));
    noFill();
    // draw points (outer + holes)
    for (const [x,y] of outerOK){
      point(penX + x*s, baselineY - y*s);
    }
    for (const pts of holes){
      for (const [x,y] of pts){
        point(penX + x*s, baselineY - y*s);
      }
    }
  }
}

function computeAdvance(gA, gB, t, advNormal){
  // schat advance op basis van bbox breedte van A + B
  function widthOf(g){
    let minX= Infinity, maxX= -Infinity;
    for (const c of g.contours){
      for (const [x,_y] of c.pts){ if (x<minX) minX=x; if (x>maxX) maxX=x; }
    }
    return maxX - minX;
  }
  const wA = widthOf(gA), wB = widthOf(gB);
  const wMix = lerp(wA, wB, t);
  const wBase = wA; // normal width baseline
  const factor = (wBase>0) ? (wMix / wBase) : 1;
  return advNormal * factor;
}

// ---------- p5
function setup(){
  const stage = document.getElementById('stage');
  const c = createCanvas(stage.clientWidth, window.innerHeight);
  c.parent('stage');
  pixelDensity(window.devicePixelRatio || 1);

  // UI refs
  ui.txt      = document.getElementById('txt');
  ui.morph    = document.getElementById('morph');
  ui.auto     = document.getElementById('auto');
  ui.capsize  = document.getElementById('capsize');
  ui.spacing  = document.getElementById('spacing');
  ui.advance  = document.getElementById('advance');
  ui.showPts  = document.getElementById('showPts');
  ui.showBox  = document.getElementById('showBox');

  // events
  ['input','change'].forEach(evt=>{
    ui.txt.addEventListener(evt, ()=> redraw());
    ui.morph.addEventListener(evt, ()=> redraw());
    ui.capsize.addEventListener(evt, ()=> redraw());
    ui.spacing.addEventListener(evt, ()=> redraw());
    ui.advance.addEventListener(evt, ()=> redraw());
    ui.showPts.addEventListener(evt, ()=> redraw());
    ui.showBox.addEventListener(evt, ()=> redraw());
  });
  ui.auto.addEventListener('change', ()=>{ if (ui.auto.checked) loop(); else noLoop(); });

  noLoop();
  (async ()=>{
    try{
      await loadGlyphs();
      ready = true; redraw();
    } catch(err){
      console.error(err);
    }
  })();
}

function windowResized(){
  const stage = document.getElementById('stage');
  resizeCanvas(stage.clientWidth, window.innerHeight);
  redraw();
}

function draw(){
  background('#0b0c0f');
  if (!ready){
    noStroke(); fill('#9aa0a6'); textAlign(CENTER,CENTER); text('Loading letters…', width/2, height/2); return;
  }

  let t = parseFloat(ui.morph.value);
  if (ui.auto.checked){
    t = (sin(millis()*0.001*PI*0.5)*0.5 + 0.5); // zachte auto-morph
    ui.morph.value = t.toFixed(3);
  }

  const cap = parseFloat(ui.capsize.value);
  const sp  = parseFloat(ui.spacing.value);
  const advN= parseFloat(ui.advance.value);
  const showPts = ui.showPts.checked;
  const showBox = ui.showBox.checked;

  const txt = (ui.txt.value || '').toUpperCase().replace(/[^ABILNO]/g,'');

  // layout: centreren horizontaal
  const yBase = height*0.55;
  let pen = 0;
  const advs = [];
  // precompute advances om centering te doen
  for (const ch of txt){
    const gA = glyphs[ch];
    const gB = glyphs[ch+'wide'];
    if (!gA || !gB) continue;
    const advPx = computeAdvance(gA, gB, t, advN);
    advs.push(advPx);
  }
  const totalAdv = advs.reduce((a,b)=>a+b,0) + sp * Math.max(0, advs.length-1);
  let penX = (width - (totalAdv * cap / glyphs['A'].H)) * 0.5; // ongeveer centreren op basis van cap-scale

  // baseline & bbox
  if (showBox){
    stroke('#283041'); strokeWeight(1); line(0, yBase, width, yBase);
  }

  // draw string
  let idx = 0;
  for (const ch of txt){
    const gA = glyphs[ch];
    const gB = glyphs[ch+'wide'];
    if (!gA || !gB) { idx++; continue; }

    const gMix = mixContours(gA, gB, t);
    //const gMix = gA; // tijdelijk: alleen normal
    drawGlyph(gMix, penX, yBase, cap, showPts);

    const advPx = advs[idx++] || advN;
    penX += (advPx + sp) * (cap / gMix.H);
  }
}
</script>
</body>
</html>
